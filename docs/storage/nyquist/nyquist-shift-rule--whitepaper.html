<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-07 Thu 18:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>"Shift Rule for Gradient Determination in Parameterised Quantum Evolutions" ‚Äî Whitepaper</title>
<meta name="author" content="Dirk Oliver Theis, University of Tartu, Estonia" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">"Shift Rule for Gradient Determination in Parameterised Quantum Evolutions" ‚Äî Whitepaper</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgdb4f3fa">1. Introduction</a></li>
<li><a href="#orga8694f0">2. Background</a>
<ul>
<li><a href="#org04f7ca5">2.1. Gradients of parameterized quantum evolutions &#x2014; why?</a>
<ul>
<li><a href="#org91a50a4">2.1.1. Quantum Machine Learning</a></li>
<li><a href="#orgba11891">2.1.2. Combinatorial Optimization</a></li>
<li><a href="#orgc144193">2.1.3. Probably not applicable: Quantum chemistry</a></li>
</ul>
</li>
<li><a href="#org597fc93">2.2. Gradients of parameterized quantum evolutions &#x2014; how?</a>
<ul>
<li><a href="#orgcec8a75">2.2.1. Symmetric Difference Quotient (SDQ)</a></li>
<li><a href="#orga7780a8">2.2.2. Shift rules</a></li>
<li><a href="#orgc12e7c3">2.2.3. Banchi-Crooks' method</a></li>
<li><a href="#org56b85c1">2.2.4. Simultaneous Perturbation Stochastic Approximation (SPSA)</a></li>
<li><a href="#org8db9499">2.2.5. Conclusion</a></li>
</ul>
</li>
<li><a href="#orge862161">2.3. Analog quantum computers (aka quantum simulators)</a>
<ul>
<li><a href="#org4570d7f">2.3.1. Rydberg atom arrays and the Rydberg Blockade                                  </a></li>
<li><a href="#org7396352">2.3.2. Other analog simulators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org37a6c2e">3. Numerical simulations</a>
<ul>
<li><a href="#orge6f69a9">3.1. Comparison with Banchi-Crooks</a></li>
<li><a href="#org9b3fada">3.2. Complementarity with Symmetric Difference Quotients</a>
<ul>
<li><a href="#orgb39ba3c">3.2.1. Hardware-software co-design</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7bcb045">4. Bibliography</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgdb4f3fa" class="outline-2">
<h2 id="orgdb4f3fa"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Most of the currently dominant proposals for useful near-term (i.e., pre-fault-tolerant) quantum computing make
use of quantum evolutions that depend on <i>parameters</i>, which need to be <i>trained</i> (i.e., optimized to minimize a
loss or error function) in order for the quantum evolution to give the desired result.  This approach is
referred to as <i>variational</i> quantum computing.
</p>

<p>
For example, in the context of IBM's recent (12/2023) update of their quantum computing roadmap, IBM showcased a
number of examples for what they call "quantum utility": Situations in which the use of a quantum computer
resulted in a if not commercial but at least scientific benefit.  Their examples either directly prepare quantum
states that are of scientific interest, or they use variational approaches.
</p>

<p>
The invention (<a href="#citeproc_bib_item_6">Theis 2022a</a>) that is discussed in this text pertains to making variational approaches
on <i>analog quantum computers</i> (aka "quantum simulators") more efficient, by speeding up the computations of
<i>gradients</i>, which are used to train the parameters.
</p>

<p>
We first discuss where and how the "Nyquist Shift Rule" method in the invention would be used and what the
state-of-the-art methods are; then we give results comparing the Nyquist shift rule to the state-of-the-art in
numerical simulations.
</p>
</div>
</div>


<div id="outline-container-orga8694f0" class="outline-2">
<h2 id="orga8694f0"><span class="section-number-2">2.</span> Background</h2>
<div class="outline-text-2" id="text-2">
<p>
With a view towards the applicability of the invention, we firstly by discussing the types of commercial
use-cases of quantum computing in which gradients are important.  Secondly, we go through the state-of-the-art
methods.  Finally, we discuss the analog quantum computers, as the hardware domain of the invention.
</p>
</div>

<div id="outline-container-org04f7ca5" class="outline-3">
<h3 id="org04f7ca5"><span class="section-number-3">2.1.</span> Gradients of parameterized quantum evolutions &#x2014; why?</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org91a50a4" class="outline-4">
<h4 id="org91a50a4"><span class="section-number-4">2.1.1.</span> Quantum Machine Learning</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
In the classical world, training a neural network amounts to optimizing the parameters it comprises in such a
way that a loss function is minimized.  In quantum machine learning, parameterized quantum processes take the
role of the classical neural network &#x2014; indeed, these parameterized quantum processes are themselves
often called quantum neural networks.
</p>

<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
The training of the parameters is not different between the quantum and classical worlds in two ways: (1)
There is (currently?) no <i>backpropagation</i> algorithm for quantum neural networks, leading to a linear
dependence of the efficiency of the training on the number of parameters (<a href="#citeproc_bib_item_1">Abbas et al. 2023</a>).
(2) Quantum measurements yield an additional source of randomness in the gradient estimates next to the
pseudo-randomness introduced by iterating over the training data.
</p>

<p>
Notably, in quantum machine learning, already for feeding input data into the parameterized quantum process
does it make sense to use parameters (<a href="#citeproc_bib_item_4">Gil Vidal and Theis 2020</a>).
</p>
</blockquote>
<p>
</div>
</p>

<p>
There is a wealth of parameterized quantum processes models that are showing promise for quantum machine
learning.  Some of them are tailored to analog quantum computers &#x2014; making our invention applicable.
</p>
</div>
</div>

<div id="outline-container-orgba11891" class="outline-4">
<h4 id="orgba11891"><span class="section-number-4">2.1.2.</span> Combinatorial Optimization</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
The most promising proposals to solving combinatorial optimization problems on noisy quantum computers encode
the cost-function to be minimized in the form of a cost Hamiltonian: The low-energy eigenstates of the
Hamiltonian correspond to low-cost solutions of the combinatorial optimization problem.  After preparing the
system in an initial state, an iterative version of adiabatic evolution is employed: In every step, for a
certain time, the system is subject to evolution that is a weighted sum of the cost Hamiltonian and the
initial-state Hamiltonian.  Typically, the weights in the sum are considered as parameters that are trained.
For that training, gradients are typically used.
</p>

<p>
Combinatorial optimization problems which require constraints (i.e., almost all) are more difficult to map
onto a Hamiltonian.  Luckily though, in analog quantum computing, sometimes QAOA-approaches can be combined
with "natural" constraints that are included in the system Hamiltonian; see the discussion about the <a href="#org2be78b4">2.3.1</a> below &#x2014; this is where our method can speed up gradient computations.
</p>
</div>
</div>

<div id="outline-container-orgc144193" class="outline-4">
<h4 id="orgc144193"><span class="section-number-4">2.1.3.</span> Probably not applicable: Quantum chemistry</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
The third large type of use-cases for parameterized quantum evolutions is quantum-computer chemistry, based,
for example, on Variational Quantum Eigensolver techniques.  While our method is in principle applicable
there, the difficulties that arise from the large number of terms in the Hamiltonians dominate, so that
gradient speed-ups have too small an effect.
</p>
</div>
</div>
</div>

<div id="outline-container-org597fc93" class="outline-3">
<h3 id="org597fc93"><span class="section-number-3">2.2.</span> Gradients of parameterized quantum evolutions &#x2014; how?</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
The most efficient way to train the parameters in parameterized quantum evolutions is Stochastic Gradient
Descent (SGD) and variants.  There, a current vector of parameters is maintained.  In every iteration, a random
estimate of the gradient is produced, and the parameter vector is updated by subtracting a multiple of the
gradient estimate.
</p>

<p>
The performance (number of iterations to achieve a near-optimal parameter setting) of SGD-variants depends
critically on two properties of the gradient estimator: Its <b>variance</b> and its <b>bias</b>.
</p>
</blockquote>
<p>
</div>
</p>

<p>
In the applications to near-term quantum computing outlined above, the loss function and its gradient are
estimated by repeatedly running the quantum evolution and then measuring.  The term <i>shot</i> is used to for a
single run of the quantum evolution with final measurement.  When considering the efficiency of noisy quantum
computations, the <i>number of shots</i> is the most important quantity, as each individual shot takes only a
negligible amount of time.
</p>

<p>
The fundamental randomness of quantum mechanical measurements leads to a variance in the gradient estimation.
The magnitude of that variance depends on what method is chosen for the gradient estimation.  The same holds
for the bias: Different methods for estimating gradients have differ with regards to whether a bias is present
and how large it is.
</p>

<p>
How are gradients of parameterized quantum evolutions obtained using state of the art methods?
</p>
</div>

<div id="outline-container-orgcec8a75" class="outline-4">
<h4 id="orgcec8a75"><span class="section-number-4">2.2.1.</span> Symmetric Difference Quotient (SDQ)</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
This simple method known from basic numerical analysis has a bias of ‚âàùúñ¬≤, where ùúñ <i>&gt; 0</i> is limited only by the
precision with which the function can be evaluated.
</p>

<p>
In the quantum setting, it works as follows: For each of the parameters in turn, SDQ runs the quantum
evolution twice, with parameter settings ùúΩ‚±º ‚Üí ùúΩ‚±º ¬±ùúñ, where ùëó is the index of the current parameter.  The
estimate for the derivative ùöç/ùöçùúΩ‚±º is the arithmetic mean of two measurements, scaled by a factor of 1/ùúñ.  In
the case of usual Pauli-measurements, the variance is ‚âà 1/ùúñ¬≤.
</p>
</blockquote>
<p>
</div>
</p>

<p>
SDQ method for estimating derivatives has the property that the bias can be arbitrarily reduced &#x2014; but any
reduction in bias is paid for by an increase in variance of equal magnitude.
</p>
</div>
</div>

<div id="outline-container-orga7780a8" class="outline-4">
<h4 id="orga7780a8"><span class="section-number-4">2.2.2.</span> Shift rules</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
Shift rules methods work similarly to SDQ: For each parameter in turn, the derivative ùöç/ùöçùúΩ‚±º is
estimated by updating only ùúΩ‚±º.
</p>
</blockquote>
<p>
</div>
</p>

<p>
In contrast to SDQ, shift rules (<a href="#citeproc_bib_item_10">Wierichs et al. 2021</a>) generally can lead to unbiased
estimators while at the same achieving the minimum possible variance that any unbiased estimator for the
derivative must have (<a href="#citeproc_bib_item_5">Theis 2021</a>).
</p>
</div>
</div>

<div id="outline-container-orgc12e7c3" class="outline-4">
<h4 id="orgc12e7c3"><span class="section-number-4">2.2.3.</span> Banchi-Crooks' method</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
Banchi and Crooks have proposed a method that they call a "stochastic approximate shift rule"
(<a href="#citeproc_bib_item_3">Banchi and Crooks 2021</a>).  The word "approximate" refers to the presence of a bias.
</p>

<p>
The advantage of their method is the following: While the standard parameter shift rules of the <a href="#orga7780a8">previous
section</a> work only in cases of standard quantum evolutions of the form ùëí‚Å±·∂ø·¥¨ &#x2014; which are typically found in
digital quantum computers &#x2014; Banchi &amp; Crooks' method can work with quantum evolutions that are typically
found in analog quantum computers (see <a href="#orge862161">2.3</a> below).
</p>

<p>
However, breaking with conventional terminology, their method requires modifications of the quantum evolution
beyond just modifying parameter values.  This results in the quantum evolutions taking longer, which means
that there is more time for quantum error to affect the outcome.  For the digital quantum computers of this
decade, this is a notable drawback.
</p>
</div>
</div>

<div id="outline-container-org56b85c1" class="outline-4">
<h4 id="org56b85c1"><span class="section-number-4">2.2.4.</span> Simultaneous Perturbation Stochastic Approximation (SPSA)</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
Both the vanilla SDQ and shift rules methods have the disadvantage that they need to be applied to each
parameter separately.  This means that the variance of the whole gradient vector will be proportional to the
number of parameters.  Hence, a good estimate of the gradient requires a number of shots that scales at least
linearly with the number of parameters.
</p>

<p>
SPSA is being discussed as a method that can give an estimate of the whole gradient vector with only a few
shots (e.g., two shots).
</p>

<p>
However, it was recently pointed out (Appendix A.2.3 in <a href="#citeproc_bib_item_1">Abbas et al. 2023</a>) that the SPSA
gradient estimator has a variance that is proportional to the number of parameters &#x2014; so SPSA offers no
advantage in reducing the number of shots in Stochastic Gradient Descent.
</p>
</div>
</div>

<div id="outline-container-org8db9499" class="outline-4">
<h4 id="org8db9499"><span class="section-number-4">2.2.5.</span> Conclusion</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
Due to low variance and absence of bias, shift rules are the gold standard for derivative computations.  But
with the exception of Banchi-Crooks' method, shift rules don't work for some of the typical parameterized
quantum evolutions on analog quantum computers.
</p>

<p>
The method described in the patent application is a parameter shift rule that targets the same type of quantum
evolutions as Banchi-Crooks' method, but it does away with the disadvantage of having to modify the quantum
evolution beyond changing parameter values.
</p>

<p>
Moreover, numerical simulations (<a href="#citeproc_bib_item_8">Theis 2023</a>, source code is available) have shown that the
method invented at the University of Tartu has smaller bias than Banchi-Crooks' method &#x2014; while quantum
hardware constraints and variance stay the same.  (Indeed, the method is in principle unbiased, biases only
result from limitations in the quantum hardware.)
</p>
</div>
</div>
</div>

<div id="outline-container-orge862161" class="outline-3">
<h3 id="orge862161"><span class="section-number-3">2.3.</span> Analog quantum computers (aka quantum simulators)</h3>
<div class="outline-text-3" id="text-2-3">
<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
<i>Digital quantum computing</i> is based on quantum circuits and quantum gates.  On the other hand, <i>analog quantum
computing</i> (also often referred to as <i>quantum simulation</i>) attempts to perform quantum evolutions not as a
sequence of quantum gates, but through continuous manipulation of the quantum Hamiltonian.
</p>

<p>
The idea is that while exact gates are a prerequisite for fault-tolerant quantum computing, entangling gates to
date still introduce significant random noise into the computation, causing decoherence.  In comparison, some
overall quantum processes can be realized through analog quantum evolutions without giving up too much
coherence.
</p>

<p>
In the past few years, in face of the rising disappointment over the failure to exploit quantum circuit based
noisy quantum computing for industrially relevant use-cases, analog quantum computing has risen to carry the
hopes for pre-fault-tolerant commercial quantum advantage.
</p>
</blockquote>
<p>
</div>
</p>

<p>
In contrast to the previously known shift rules for quantum circuits, my method (<a href="#citeproc_bib_item_6">Theis 2022a</a>) works
well with typical situation in an analog quantum computer: The part of the Hamiltonian that expresses a
parameter under consideration is active simultaneously with other, non-commuting parts.
</p>
</div>


<div id="outline-container-org4570d7f" class="outline-4">
<h4 id="org4570d7f"><span class="section-number-4">2.3.1.</span> Rydberg atom arrays and the Rydberg Blockade                                  <a id="org2be78b4"></a></h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
<div style="color:gray;">
</p>
<blockquote>
<p>
The "Stable Set Problem" (also known as, "Maximum Independent Set Problem") is a classical &#x2014; and famously
hard to approximate &#x2014; combinatorial optimization problem.  Formulated on an intuitive level, when given as
input a set of objects any two of which might be <i>incompatible</i> with eat other, the Stable Set Problem asks
for finding the largest (or most highly weighted) sub-collection of pairwise compatible objects.  A great
variety of combinatorial optimization problems can be derived as Stable Set with additional constraints, or
reduced to Stable Set in a simple way.
</p>

<p>
Atom arrays, held in place (or even bussed around) with optical tweezers, offer a natural analog-quantum
formulation for Stable Set by exploiting the Rydberg blockade: If two atoms are in close proximity, there is a
heavy energy penalty for both of to be are in the excited "Rydberg" state.  It is intuitive that the
<i>incompatibility</i> relation can be modeled by identifying atoms with objects and bringing atoms representing
incompatible objects into close proximity before sending the pulses which effect the transition into the
excited state.
</p>

<p>
Next to Stable Set, atom arrays have also successfully been used for solving so-called Max-Cut (or Ising)
problems.
</p>
</blockquote>
<p>
</div>
</p>


<p>
Various publications over the last year have demonstrated the power of (reconfigurable) Rydberg atom arrays.
While the most head-turning one of them is based on quantum error correction, until a major problem &#x2014; the
continuous refill or reuse of atoms &#x2014; is solved, error corrected quantum computing on reconfigurable atom
arrays remains out of reach.  Hence, it appears that hopes for commercial quantum advantage based on Rydberg
atoms within this decade still rest on analog simulators.
</p>
</div>
</div>

<div id="outline-container-org7396352" class="outline-4">
<h4 id="org7396352"><span class="section-number-4">2.3.2.</span> Other analog simulators</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Couplers between qubits in superconducting circuits can be used in an analog way, which is exploited, e.g., in
<i>digital-analog quantum computing/simulation</i>.  Derivative of the parameters within single qubits pulses can
then be taken using our method.  In superconducting qubit literature, analog quantum computing is sometimes
referred to under the term <i>sub-logical</i> control (e.g., <a href="#citeproc_bib_item_2">Babbush and Neven 2016</a>).
</p>

<p>
There have been publications using Trapped Ion quantum computers in an analog way.  However, I am
insufficiently familiar with that qubit platform to judge whether our method is applicable there, or even
whether analog quantum computing is still pursued on trapped ions at all.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org37a6c2e" class="outline-2">
<h2 id="org37a6c2e"><span class="section-number-2">3.</span> Numerical simulations</h2>
<div class="outline-text-2" id="text-3">
<p>
Basic facts in signal processing suggest that the Nyquist shift rule might perform badly if the following two
factors occur together:
</p>

<ol class="org-ol">
<li>The quantum evolution whose derivative is to be taken contains strong contributions of low (non-zero)
frequencies;</li>
<li>The width of the range in which the parameter values can be taken is restricted through constraints imposed
by the quantum device.</li>
</ol>

<p>
More accurately, the Nyquist shift rule can be expected to perform well if the width of the parameter range is
inverse proportional to the lowest relevant frequency.
</p>

<p>
As in today's quantum devices, the parameter range is typically restricted, we have conducted experiments how
this &#x2014; and other &#x2014; constraints affect the relative performance of the method.
</p>
</div>

<div id="outline-container-orge6f69a9" class="outline-3">
<h3 id="orge6f69a9"><span class="section-number-3">3.1.</span> Comparison with Banchi-Crooks</h3>
<div class="outline-text-3" id="text-3-1">
<p>
To compare Nyquist shift rules with the method of Banchi &amp; Crooks (<a href="#citeproc_bib_item_3">Banchi and Crooks 2021</a>),
we conducted numercial simulations in a generic setting.
</p>

<p>
The accuracy (i.e., bias) of Banchi-Crooks' method can be tuned: A higher accuracy requires a larger width of
the parameter range that needs to be accessed.  In our numerical experiments indicate that, we set up the
Nyquist shift rule to operate in the same parameter range width as Banchi-Crooks' method.  The results indicate
that, for all widths, the Nyquist shift rule has an order of magnitude better accuracy
(<a href="#citeproc_bib_item_8">Theis 2023</a>).
</p>

<p>
The source code for said experiments is available for inspection and further tests
(<a href="#citeproc_bib_item_7">Theis 2022b</a>).
</p>
</div>
</div>

<div id="outline-container-org9b3fada" class="outline-3">
<h3 id="org9b3fada"><span class="section-number-3">3.2.</span> Complementarity with Symmetric Difference Quotients</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Symmetric Difference Quotients have complementary behavior to the Nyquist shift rule: While the bias of the
Nyquist shift deteriorates with the influence of low frequencies, the bias and variance of SDQ are proportional
to the largest frequencies that occur.  The situation mirrors that of standard parameter shift rules, which
outperform SDQ unless the largest frequency is large (in which case all methods require either large variance
or large bias).
</p>

<p>
In work that is currently being written down, we have compared SDQ and Nyquist shift rule in realistic
simulations of Rydberg atom array analog quantum computing devices with typical current-day constraints
(<a href="#citeproc_bib_item_9">Theis 2024</a>).  Not only the parameter ranges, but also other relevant constraints were taken into
account in the numerical simulations.  The results of the simulations indicated that a comparison of the
parameter range with an easily available bound on the frequency of the quantum evolution helps to recognize the
quantum evolutions where the Nyquist shift rule yields a considerable improvement.
</p>

<p>
The source code for said experiments will be made available for inspection and further tests.
</p>
</div>

<div id="outline-container-orgb39ba3c" class="outline-4">
<h4 id="orgb39ba3c"><span class="section-number-4">3.2.1.</span> Hardware-software co-design</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
The work just described revealed an opportunity to improve the system performance of the analog quantum
computer by co-designing with the gradient-estimation method: An increase in the width of the parameter ranges
leads to improved performance of the Nyquist gradient estimator.  Gradient estimation is a critical factor
influencing the efficiency of training Quantum Neural Networks or optimizing Quantum Approximate Optimization
Algorithm models.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7bcb045" class="outline-2">
<h2 id="org7bcb045"><span class="section-number-2">4.</span> Bibliography</h2>
<div class="outline-text-2" id="text-4">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Abbas, Amira, Robbie King, Hsin-Yuan Huang, William J. Huggins, Ramis Movassagh, Dar Gilboa, and Jarrod R. McClean. 2023. ‚ÄúOn Quantum Backpropagation, Information Reuse, and Cheating Measurement Collapse.‚Äù <i>Preprint Arxiv:2305.13362</i>. <a href="https://doi.org/10.48550/arXiv.2305.13362">https://doi.org/10.48550/arXiv.2305.13362</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Babbush, Ryan, and Hartmut Neven. 2016. ‚ÄúTraining Quantum Evolutions Using Sublogical Controls.‚Äù US 10,275,717 B2; US 11,055,626 B2; US 11,562,285 B2.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_3"></a>Banchi, Leonardo, and Gavin E. Crooks. 2021. ‚ÄúMeasuring Analytic Gradients of General Quantum Evolution with the Stochastic Parameter Shift Rule.‚Äù <i>Quantum</i> 5 (January): 386. <a href="https://doi.org/10.22331/q-2021-01-25-386">https://doi.org/10.22331/q-2021-01-25-386</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_4"></a>Gil Vidal, Javier, and Dirk Oliver Theis. 2020. ‚ÄúInput Redundancy for Parameterized Quantum Circuits.‚Äù <i>Frontiers in Physics</i> 8: 297. <a href="https://doi.org/10.48550/arXiv.1901.11434">https://doi.org/10.48550/arXiv.1901.11434</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_5"></a>Theis, Dirk Oliver. 2021. ‚ÄúOptimality of Finite-Support Parameter Shift Rules for Derivatives of Variational Quantum Circuits.‚Äù <i>Preprint</i>. <a href="https://doi.org/10.48550/arXiv.2112.14669">https://doi.org/10.48550/arXiv.2112.14669</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_6"></a>‚Äî‚Äî‚Äî. 2022a. ‚ÄúShift Rule for Gradient Determination in Parameterised Quantum Evolutions.‚Äù US17/856,357; PCT/EP2023/068112.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_7"></a>‚Äî‚Äî‚Äî. 2022b. ‚ÄúSupplementary Material for ‚Äô``Proper‚Äô‚Äô Shift Rules‚Ä¶‚Äô.‚Äù Julia Notebooks. <a href="https://dojt.github.io/storage/nyquist/">https://dojt.github.io/storage/nyquist/</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_8"></a>‚Äî‚Äî‚Äî. 2023. ‚Äú``Proper‚Äô‚Äô Shift Rules for Derivatives of Perturbed-Parametric Quantum Evolutions.‚Äù <i>Quantum</i> 7: 1052. <a href="https://doi.org/10.22331/q-2023-07-11-1052">https://doi.org/10.22331/q-2023-07-11-1052</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_9"></a>‚Äî‚Äî‚Äî. 2024. ‚ÄúDerivatives of Parameterized Bang-Bang Pulses in Rydberg-Array Analog Quantum Computers.‚Äù</div>
  <div class="csl-entry"><a id="citeproc_bib_item_10"></a>Wierichs, David, Josh Izaac, Cody Wang, and Cedric Yen-Yu Lin. 2021. ‚ÄúGeneral Parameter-Shift Rules for Quantum Gradients.‚Äù <i>Preprint</i>. <a href="https://doi.org/10.48550/arXiv.2107.12390">https://doi.org/10.48550/arXiv.2107.12390</a>.</div>
</div>
<hr />
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: Wed Feb  7 12:34:09 CET 2024</p>
<p class="author">Author: Dirk Oliver Theis, University of Tartu, Estonia</p>
<p class="date">Created: 2024-03-07 Thu 18:26</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
